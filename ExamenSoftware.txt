								INGENIERIA INVERSA
La ingeniería inversa (en inglés, reverse engineering) s el proceso de descubrir los principios tecnológicos de un objeto, herramienta, dispositivo o sistema, mediante el razonamiento adictivo 
(haciendo conjeturas) de su estructura, función y operación. Dicho de otra manera, se trata de tomar algo, por ejemplo un dispositivo mecánico o electrónico, 
para analizar su funcionamiento en detalle, con el objetivo de crear un dispositivo que haga la misma tarea o una similar sin copiar los detalles del original.

OBJETIVO
	La ingeniería inversa persigue el objetivo de obtener la mayor cantidad de información técnica de un producto, del cual no se tiene la más mínima información 
técnica de su diseño, construcción y funcionamiento, de modo que se debe partir de un todo para comprender cada pieza del sistema, para lo cual se deben tomar 
notas muy detalladas.

ANTECEDENTES
	La ingeniería inversa es una rama de la ingeniería relativamente reciente, cuyos orígenes se remontan a la Segunda Guerra Mundial, 
cuando alguno de los dos bandos (Aliados y Potencias del Eje) capturaba maquinaria o equipo del otro bando, 
entonces se disponían a conocer hasta el más mínimo detalle de la tecnología del enemigo con el objetivo de encontrar fallas o puntos débiles que 
les brindarán cierta ventaja.


USOS
	La ingeniería inversa tiene muchas aplicaciones en el mundo actual y es aplicada por todo tipo de empresas, de todos los ámbitos tecnológicos. 
Algunos de los usos principales son:
-Investigar, analizar y comprender la tecnología utilizada por otras naciones o por otras empresas.
-Analizar los productos de la competencia para analizar sin infringen alguna patente de otra empresa.
-Desarrollar productos que sean compatibles con otros productos, sin tener acceso a los detalles técnicos de estos últimos.
-Comprobar la seguridad de un producto, en informática por ejemplo, para conocer las brechas de seguridad que puede tener un programa.

DIVISION
	Actualmente la ingeniería inversa se divide en dos grandes vertientes: ingeniería inversa de producto e ingeniería inversa de software; 
en la primera entran todos aquellos productos físicos tales como máquinas, componentes electrónicos, dispositivos, etc., y en la segunda protocolos, 
códigos de programación, aplicaciones digitales, etc. No es una definición completamente establecida pero es la más aceptada actualmente.

¿Ingeniería inversa?
Las tareas habituales de la ingeniería implican seguir la dirección de lo específico a lo general, pero la ingeniería inversa indica que 
las labores deben realizarse siguiendo la dirección opuesta, de lo general a lo específico, algo poco común para los ingenieros, 
que implica invertir el modo de pensamiento y que sin duda es un gran ejercicio de pensamiento además que es una habilidad de mucha importancia hoy en día.

¿Método de aprendizaje?
La ingeniería inversa no es un método de solución sino más bien de aprendizaje, como implica analizar un objeto hasta el punto de comprender cada uno de 
sus componentes y sus funciones entonces la cantidad de conocimientos obtenida será bastante, pero solo hemos aprendido, 
para solucionar el problema deberemos aplicar lo aprendido y comenzar de cero nuevamente.

¿Problemas legales?
Si se sigue un proceso de ingeniería inversa bien establecido no tiene por qué haber ningún problema legal; esto implica cumplir al pie de la letra 
el objetivo de la ingeniería inversa: obtener un producto que haga lo mismo pero que sea nuevo, que no aplique los mismos principios de funcionamiento del
producto analizado; es decir, la ingeniería inversa se debe utilizar solamente para conocer un producto, con el fin de hacer uno que haga lo mismo pero de otro modo.

Ventajas de la Ingeniería inversa
La aplicación de ingeniería inversa nunca cambia la funcionalidad del producto objeto de la aplicación sino que permite obtener productos que indican cómo se ha construido el mismo. Su realización permite obtener los siguientes beneficios:
• Reducir la complejidad del sistema: al intentar comprender el software se facilita su mantenimiento y la complejidad existente disminuye.
• Generar diferentes alternativas: del punto de partida del proceso, principalmente código fuente, se generan representaciones gráficas lo que facilita su comprensión.
• Recuperar y/o actualizar la información perdida (cambios que no se documentaron en su momento): en la evolución del sistema se realizan cambios que no se suele actualizar en las representaciones de nivel de abstracción más alto, para lo cual se utiliza la recuperación de diseño.
• Detectar efectos laterales: los cambios que se puedan realizar en un sistema puede conducirnos a que surjan efectos no deseados, esta serie de anomalías puede ser detectados por la ingeniería inversa.
• Facilitar la reutilización: por medio de la ingeniería inversa se pueden detectar componentes de posible reutilización de sistemas existentes, pudiendo aumentar la productividad, reducir los costes y los riesgos de mantenimiento.

Referencias
 La Dirección Estratégica de la Empresa. Teoría y aplicaciones. José Emilio Navas / Luis Ángel Guerras. Ed. Civitas. 3ª ed.
 www.alegsa.com.ar › Diccionario tecnología › Piratería y hacking


								MANTENIMIENTO DE SOFTWARE
	Es la modificación de un producto de software después de la entrega, para corregir errores, mejorar el rendimiento, u otros atributos. 
El mantenimiento del software es una de las actividades más comunes en la ingeniería de software.

	El mantenimiento de software es también una de las fases en el ciclo de vida de desarrollo de sistemas, que se aplica al desarrollo de software.
La fase de mantenimiento es la fase que viene después del despliegue (implementación) del software en el campo.Los problemas claves de mantenimiento 
de software son administrativos y técnicos. Problemas clave de administración son: alineación con las prioridades del cliente, dotación de personal, 
cuál organización hace mantenimiento, estimación de costos. Son cuestiones técnicas claves: limitado entendimiento, análisis de impacto, pruebas (testing), 
medición de mantenibilidad.

	El mantenimiento de software es una actividad muy amplia que incluye la corrección de errores, mejoras de las capacidades, eliminación de funciones obsoletas 
y optimización. Debido a que el cambio es inevitable, se debe desarrollar mecanismos para la evaluación, controlar y hacer modificaciones.

 Clasificacion de actividades de mantenimiento en cuatro clases:

	Adaptable – modificar el sistema para hacer frente a cambios en el ambiente del software (DBMS, OS)
	Perfectivo – implementar nuevos, o cambiar requerimientos de usuario referentes a mejoras funcionales para el software
	Correctivo, diagnosticar y corregir errores, posiblemente los encontraron por los usuarios
	Preventiva – aumentar la capacidad de mantenimiento de software o fiabilidad para evitar problemas en el futuro

FASE DE MANTENIMIENTO

	La fase de mantenimiento de software involucra cambios al software para corregir defectos encontrados durante su uso o la adición de nueva 
funcionalidad mejorando la usabilidad y aplicabilidad del software. El mantenimiento del software involucra diferentes técnicas específicas. 
Una técnica es el rebanamiento estático, la cual es usada para identificar todo el código de programa que puede modificar alguna variable.

	La fase de mantenimiento de software es una parte explícita del modelo en cascada del proceso de desarrollo de software el cual fue desarrollado 
durante el movimiento de programación estructurada en computadores. El otro gran modelo, el Desarrollo en espiral desarrollado durante el movimiento de 
ingeniería de software orientada a objeto no hace una mención explícita de la fase de mantenimiento. Sin embargo, esta actividad es notable, considerando el 
hecho de que dos tercios del coste del tiempo de vida de un sistema de software involucran mantenimiento.

MANTENIMIENTO PREVENTIVO DEL SOFTWARE

	El mantenimiento preventivo consiste en una atención constante de limpieza, revisión y afinación de los distintos elementos integrantes 
de un equipo de cómputo. Es importante saber que la mayoría de los problemas que se presentan en el trabajo cotidiano, se debe a la falta de un programa 
específico de mantenimiento de los equipos, de tal manera que la mayoría de los problemas se resuelven con el mismo procedimiento del mantenimiento preventivo. 
El mantenimiento tiene técnicas para darle un periodo de vida útil más largo y libre de fallas. Debemos de tener en cuenta que es necesario darle mantenimiento
al software ya que el continuo uso genera una serie de cambios en la configuración original del sistema, causando bajas en el rendimiento que al acumularse 
con el tiempo pueden generar problemas serios. Actualmente es indispensable mantener actualizada la protección contra virus informáticos.

TIPOS DE ACTIVIDADES
 Basili et al. [1996] identifican las siguientes once actividades, que se realizan con cada modificación del software:
	-Análisis de impacto y de costes/beneficios: se dedica esta actividad a analizar diferentes alternativas de implementación y/o a comprobar su 
						     impacto en la planificación, coste y facilidad de operación.
	-Comprensión del cambio: puede consistir en localizar el error y determinar su causa, o en comprender los requisitos de una mejora solicitada.
	-Diseño del cambio: se refiere al diseño propuesto para el cambio, pudiéndose incluir un rediseño del sistema.
	-Codificación y pruebas unitarias: se codifica y prueba el funcionamiento de cada componente modificado.
	-Inspección, certificación y consultoría: esta actividad se dedica a inspeccionar el cambio, comprobar otros diseños, reuniones de inspección, etc.
	-Pruebas de integración: se refiere a comprobar la integración de los componentes modificados con el resto del sistema.
	-Pruebas de aceptación: en esta actividad, el usuario comprueba, junto al personal encargado del mantenimiento, la adecuación del cambio a sus necesidades.
	-Pruebas de regresión: en esta actividad se somete el software modificado a casos de pruebas previamente almacenados y por los que ya pasó.
	-Documentación del sistema: se revisa y reescribe, en caso necesario, la documentación del sistema para que se ajuste al producto software ya modificado.
	-Otra documentación (del usuario, por ejemplo): se revisa y reescribe, en caso necesario, los diferentes manuales de usuario y otra documentación, 
							excepto la documentación del sistema.
	-Otras actividades, como las dedicadas a la gestión del proyecto de mantenimiento.


								EVOLUCION DEL SOFTWARE

	El Software representa la vida interna de un computador, el manejo y aprovechamiento del mismo y todas las ventajas que se brindan el mundo de las 
computadoras,depende del software, facilitando a los usuarios el desarrollo de programas que contribuyen con tareas diarias tanto personales como generales, 
empresariales y organizacionales el software en sus diferentes tipos es el elemento esencial como interfaz entre usuario - computador, su historia desde 
un principio se muestra con poca atención pero con el paso del tiempo se ha tornado importante para los programadores y creadores de sistemas tanto de 
aplicación como operativos, todo lo que se ve digitalizado en un computador representa el software clasificado de alguna forma, las herramientas del menú 
inicio y todas aquellas que se despliegan al encendido del CPU, el desarrollo de esta herramienta ha permitido innovar en cuanto a la robótica he inteligencia 
artificial facilitando el trabajo en determinadas áreas laborales y agilizando las mismas por ejemplo en la fabricación de vehículos mediante software de 
programación se diseñan estructuras robóticas inmensas y fuertes que realizan tareas que al brazo humano le tomarían mas tiempo.

RESEÑA HISTORICA DEL SOFTEWARE
	En 1990 La crisis del software se fundamentó en el tiempo de creación de software, ya que en la creación del mismo no se obtenían los resultados deseados,
además de un gran costo y poca flexibilidad.
	Es un término informático acuñado en 1968, en la primera conferencia organizada por la OTAN sobre desarrollo de software, de la cual nació formalmente la 
rama de la ingeniería de software. El término se adjudica a F. L. Bauer, aunque previamente había sido utilizado por Edsger Dijkstra en su obra The Humble 
Programmer.
	Básicamente, la crisis del software se refiere a la dificultad en escribir programas libres de defectos, fácilmente comprensibles, y que sean verificables. 
Las causas son, entre otras, la complejidad que supone la tarea de programar, y los cambios a los que se tiene que ver sometido un programa para ser continuamente 
adaptado a las necesidades de los usuarios.
	Además, no existen todavía herramientas que permitan estimar de una manera exacta, antes de comenzar el proyecto, cuál es el esfuerzo que se necesitará para 
desarrollar un programa. Este hecho provoca que la mayoría de las veces no sea posible estimar cuánto tiempo llevará un proyecto, ni cuánto personal será necesario.
Cuando se fijan plazos normalmente no se cumplen por este hecho. Del mismo modo, en muchas ocasiones el personal asignado a un proyecto se incrementa con la 
esperanza de disminuir el plazo de ejecución.Por último, las aplicaciones de hoy en día son programas muy complejos, inabordables por una sola persona. 
En sus comienzos se valoró como causa también la inmadurez
de la ingeniería de software, aunque todavía hoy en día no es posible realizar estimaciones precisas del coste y tiempo que necesitará un proyecto de software.
Englobó a una serie de sucesos que se venían observando en los proyectos de desarrollo de software:
Los proyectos no terminaban en plazo.
Los proyectos no se ajustaban al presupuesto inicial.
Baja calidad del software generado.
Software que no cumplía las especificaciones.
Código inmantenible que dificultaba la gestión y evolución del proyecto.
Aunque se han propuesto diversas metodologías para intentar subsanar los problemas mencionados, lo cierto es que todavía hoy no existe ningún método que haya
 permitido estimar de manera fiable el coste y duración de un proyecto antes de sus comienzos.
En 1984 Richard Stallman deja el MIT y comienza a trabajar en su proyecto GNU, con el objetivo de desarrollar un sistema operativo completamente libre, desde 
el kernel, editores, compiladores, debuggers, hasta utilitarios más complejos como procesadores de texto e inclusive juegos. Uno de los primeros desarrollos
 realizados por el mismo Stallman fue el editor de textos GNU Emacs a principios de 1985. Ese mismo año se funda la Free Software Fundation, ente
 que financia desde entonces al proyecto GNU, la misma se mantiene con donaciones y con el producto de la venta de CD-ROMs tanto de programas binarios como
 código fuente, manuales y distribuciones completas (conjunto de software para una dada plataforma de hardware).
En este punto conviene aclarar la distinción entre software libre y software gratuito. Se entiende que el poseedor de software libre tiene la libertad de:
	-Ejecutar el programa.
	-Modificar el programa (para que este punto tenga sentido es necesario que el programa sea distribuido con el código fuente).
	-Redistribuir copias del programa (ya sea gratis o no).
	-Distribuir copias modificadas del programa.

	Con el tiempo, los programadores de la Free Software Fundation fueron completando algunas de las tareas planeadas originalmente por el proyecto GNU,
entre otros la biblioteca de lenguaje "C", y el shell más utilizado en los sistemas GNU/Linux: bash. El éxito conseguido por estos programas que no sólo 
trabajan en sistemas GNU/Linux, sino que han sido portados a otras plataformas, forzaron a sus desarrolladores a dedicar un tiempo importante a su mantenimiento
y mejora. De esta manera, el desarrollo completo de un sistema operativo basado en software libre se vio demorado por algunos años.

	Por otra parte, además de los productos de la FSF, existen otros desarrollos de software libre que fueron aprovechados por el proyecto GNU, 
entre los más importantes están el TeX como procesador de textos y el X Windows System como sistema gráfico de interfase con el usuario.
Alrededor de 1990 el único componente básico del sistema que estaba faltando era el kernel. La decisión que se tomó en ese momento fue utilizar el microkernel
 Mach (desarrollado por las universidades Carnegie Mellon y la de Utah), adicionándole una serie de procesos servidores desarrollados por la FSF. 
A esta combinación  de un micro-kernel con procesos servidores independientes se le llamó HURD. Recién desde los últimos meses de 1999 HURD ha comenzado a 
ser utilizado en forma confiable. Mucho antes de que esto sucediera, un estudiante finlandés, Linus Torvalds, desarrolló un kernel para computadoras basadas 
en el procesador  Intel 386, compatible con unix, que llamó LINUX. Este kernel fue también desarrollado como software libre, y rápidamente fue creciendo 
merced a la colaboración de programadores de todo el mundo. En este momento Linux ha sido portado a toda la gama de procesadores Intel a partir del i386: 
(486, Pentium, Pentium II y III, Celeron), a procesadores para PC's de Cyrix y de AMD, e incluso a procesadores tipo sparc (SUN), a los procesadores Motorola 68000 
(Apple MacIntosh), a procesadores Alpha (de 64 bits, utilizados por Compaq, antes Digital). De esta manera, alrededor de 1992 fue posible combinar el kernel Linux 
con los utilitarios del proyecto GNU y surgió el primer sistema operativo completamente basado en software libre.

TIPOS DE SOFTWARE, DESCRIPCION Y EJEMPLOS
	Software de sistema
Es el software básico o sistema operativo. Es un conjunto de programas cuyo objeto es facilitar el uso del computador (aísla de la complejidad de cada dispositivo, 
y presenta al exterior un modelo común de sistema de manejo para todos los dispositivos) y conseguir que se use eficientemente (ejemplo: realizar operaciones 
mientras se ejecuta un programa). Administra y asigna los recursos del sistema (hard-ware), ejemplo windows xp, edition, vista, ms-dos, lunix, unix, mac, e incluido 
en este se encuentran los Programas de utilidad: (se le podrían llamar también software de mantenimiento): desfragementador de discos, liberador de espacio etc.
	Software de Aplicación
Son los programas que controlan y optimización la operación de la máquina, establecen una relación básica y fundamental entre el usuario y el computador, hacen que 
el usuario pueda usar en forma cómoda y amigable complejos sistemas hardware, realizan funciones que para el usuario serían engorrosas o incluso imposibles, y actúan 
como intermediario entre el usuario y el hardware, ejemplo cuando nos vamos a inicio\todos los programas. y todos los que aparezcan ahí, instalados así se les 
llaman "software de aplicación".
	La Robótica y el Software de Sistemas Operativos
Permite examinar en detalle el comportamiento estático y dinámico de dispositivos cinemáticos (por ejemplo robots). Es una herramienta muy potente tanto las 
aplicaciones de ingeniería robótica, I+D y test de rendimiento de sistemas robóticos. Permiten una gran flexibilidad en el análisis del comportamiento de sistemas 
cinemáticos complejos. Muestra los resultados de forma gráfica. Está concebido como el osciloscopio para la robótica.
Los robots son utilizados en una diversidad de aplicaciones, desde robots tortugas en los salones de clases, robots soldadores en la
industria automotriz, hasta brazos teleoperados en el transbordador espacial.
Cada robot lleva consigo su problemática propia y sus soluciones afines; no obstante que mucha gente considera que la automatización de procesos a
través de robots está en sus inicios, es un hecho innegable que la introducción de la tecnología robótica en la industria, ya ha causado un gran impacto. 
En este sentido la industria Automotriz desempeña un papel preponderante.
El gigante de la informática Microsoft lanzo un sistema operativo para robots. Bajo el nombre de Microsoft Robotics Studio, pretende
 facilitar la labor de quienes se dedican a la programación de robots reales o simulados y, de paso, ocupar una posición más relevante en la industria de la robótica.
Este sistema operativo sirve para programar todo tipo de robots, tanto de juguete como aquellos que se utilizan en las industrias, y estará a disposición de 
investigadores y aficionados de forma gratuita.
La Inteligencia Artificial como tendencia en Sistemas Operativos
Llamada polisemia, la que los diferencia, como veremos, de los códigos computacionales.
En la actualidad, el problema de la comprensión del lenguaje natural por las máquinas dista mucho de estar resuelto, pero, como en el caso del procesamiento 
de voz, hay aproximaciones de utilidad práctica. La primera, la menos sofisticada, que no puede considerarse inteligencia artificial, consiste en hacer que el 
programa dirija el dialogo, forzando al usuario a responderle dentro de unos marcos muy rígidos, ya sea por medio de selecciones en menú, o mediante preguntas 
escogidas que sólo puedan responderse con SI o NO. Evidentemente, tendremos un dialogo en lenguaje natural, pero el usuario no ha llegado a escribir una sola
 frase completa.
En una segunda aproximación, lo que el programa interpreta no es un lenguaje natural sin restricciones, sino una versión simplificada, con reglas gramaticales
 más estrictas que las ordinarias, para evitar la ambigüedad. Podríamos, por ejemplo, forzar al usuario a utilizar siempre oraciones de Las forma
sujeto-verbo-complemento directo.
En la tercera aproximación, dejaremos libre la sintaxis del lenguaje, pero se restringe el ámbito semántico, es decir, los sentidos posibles de las palabras. 
Esta técnica se utiliza a menudo en la interfaz de usuario de los sistemas expertos, en los que el tema sobre el que se esta dialogando se constriñe a un campo
muy concreto. Por ejemplo, en un sistema experto en diagnostico medico, las palabras posiblemente ambiguas tomaran con preferencia aquel significado que tenga 
algo que ver con la medicina. Además, y para ganar tiempo, el programa no suele analizar la sintaxis del texto que ha recibido, sino que se apoya únicamente en
los términos más importantes para deducir el significado de la frase, en el contexto de la conversación.
Windows 7
Descripción
Es la última versión de Microsoft Windows, (anteriormente conocido con nombre código Blackcomb, y luego Vienna), un sistema operativo producido por Microsoft
Corporation para uso en PCs, incluyendo equipos de escritorio en hogares y oficinas, Notebooks, tablet PCs, netbooks y equipos media center.
A diferencia de su predecesor, Windows 7 es una actualización incremental del núcleo NT 6.0, esto con la meta de mantener cierto grado de compatibilidad con 
aplicaciones y hardware en los que su antecesor Windows Vista ya era compatible. Las metas de desarrollo para Windows 7 fueron el mejorar su interfaz para hacerla 
más amena al usuario, con nuevas características que permiten hacer tareas de una manera más fácil y rápida, al mismo tiempo en que se realizaron esfuerzos para 
lograr un sistema más ligero, estable y rápido. Diversas presentaciones dadas por la compañía en el 2008 se enfocaron en demostrar capacidades táctiles multi-touch, 
una interfaz rediseñada junto con una nueva barra de tareas y un sistema de redes domésticas denominado Grupo en el Hogar, además de mejoras en el rendimiento.
Características
Windows 7 incluye numerosas nuevas actualizaciones, entre las que se encuentran avances en reconocimiento de voz, táctil y escritura, soporte para discos virtuales,
mejor desempeño en procesadores multi-núcleo, mejor arranque y mejoras en el núcleo.
Muchas nuevas características se agregaron al Panel de Control como: Aceleradores, Gadgets, Infrarrojo, Solución de problemas, Localización y otros sensores,
 Administrador de Credenciales, Windows Solution Center, entre otros.
Se hicieron grandes cambios en programas como WordPad, Paint, Calculadora y Teclado en pantalla.
La barra lateral de Windows o más conocida como Windows Sidebar se ha eliminado y ahora los gadgets pueden ubicarse libremente en cualquier lugar del escritorio.
Impresoras y dispositivos: Nuevo item del panel del control en la que se tendrá acceso a todo el hardware que se conecte al PC (marcos digitales, impresoras, cámaras
 fotográficas, etc). Junto a esto se ha incluido Device Stage, es un administrador de dispositivos móviles que ayuda a los usuarios a sincronizar música, vídeos, 
fotos y da información acerca del estado de la tarjeta SIM, la carga de la batería, mensajes, etc.
Aero Snaps: Permite cambiar el tamaño de una ventana simplemente con arrastrarla a un extremo de la pantalla, por ejemplo, si se arrastra al tope se maximiza,
 a la derecha o izquierda ocupa el 50% de la pantalla según el lado al que la arrastremos y si la arrastramos nuevamente al centro toma el tamaño original.
Funcionalidades
Windows 7 estará más enfocado en el rendimiento del sistema operativo. En el blog oficial Microsoft publicó seis de los puntos más relevantes a trabajar: empleo de
 memoria, utilización de CPU, operaciones de entrada y salida a disco, operaciones de arranque, cierre y reposo, rendimiento del sistema base y empleo de disco por
 parte del sistema.
En una entrevista con Newsweek, Bill Gates dijo que esta nueva versión de Windows estaría más centrada en el usuario; además comentó que trabajan con esmero para
mejorar el rendimiento.
También uno de sus principales objetivos es mejorar el arranque y tienen como propósito que inicie en menos de 15 segundos. Para esto se propusieron reducir
la cantidad de programas y servicios que se inician al cargar Windows.
Otra cosa muy presente en el desarrollo de este sistema (gracias a las quejas de los usuarios) es minimizar la intrusión, mejorar el rendimiento y habilitar la 
modificación del Control de Cuentas de Usuario, ya que éste fue un total fracaso en Windows Vista debido a sus constantes alertas innecesarias en simples acciones 
diarias.
Software Asociado
Compatibilidad:
Las versiones cliente de Windows 7 serán lanzadas en versiones para arquitectura 32 bits y 64 bits en versiones para Professional y Home. No obstante, las versiones
servidor de este producto serán lanzadas exclusivamente para arquitectura 64 bits.
Esto significa que, las versiones cliente de 32 bits aún soportarán programas Windows 16 bits y MS-DOS. Y las versiones 64 bits 
(incluyendo todas las versiones de servidor), soportarán tanto programas de 32 como de 64 bits.
